tmux-kill-detached-sessions() {
  tmux list-sessions | grep -v attached | grep -E '^\d{1,3}' | awk -F: '{print $1}' | xargs -I {} tmux kill-session -t {}
}

zinit-update() {
  zinit delete --clean
  zinit update --all
  zinit cclear
}

# add key to remove server
ssh-add-key() {
  ssh-copy-id -i ~/.ssh/id_rsa.pub $1
  ssh $1
}

# a touch command which creates folders too
function touchp() {
  mkdir -p $(dirname $1) && touch "$1"
}

# All the dig info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# determine if we are in a node_modules folder or if a valid node_modules path was passed via any argument
function _is_node_modules() {
  local node_modules_path=$1

  if [[ -z "$node_modules_path" ]]; then
    node_modules_path=$(pwd)
  fi

  [[ "$node_modules_path" =~ node_modules$ ]]
}

alias ff="fzf --preview='bat --color=always {}'"

# TODO this should use the `cd` thing and just overload there instead
fdd() {
  local additional_args=""
  if _is_node_modules "$@"; then
    additional_args="--no-ignore-vcs --hidden"
  fi

  local file_or_directory=$(fd ${=additional_args} "$@" | fzf --preview 'exa -1 --color=always {}'
)

  if [[ ! -z "$file_or_directory" ]]; then
    cd $file_or_directory
  fi
}

# livegrep-like local search
# related: https://github.com/seletskiy/zsh-fuzzy-search-and-edit/blob/master/plugin.zsh
rgg() {
  local additional_args=""

  # TODO should check search page in $@ as well
  # TODO should check if in a .venv folder
  if [[ $(pwd) =~ node_modules$ ]] || [[ $(pwd) == *"/.venv/"* ]]; then
    # in this case, we want to search the contents of the node_modules directory
    # this is a common case for me, trying to debug various package bugs in a project I'm working on
    additional_args="--no-ignore-vcs --hidden"
  fi

  # TODO --bind=\"ctrl-y:execute-silent(echo {} | cut -d: -f1 | tr -d '[:space:]' | pbcopy)\" \
  local file_and_location=$(rg --color always --hidden "$@" ${=additional_args} | fzf --ansi --delimiter : --with-nth '1,4' --preview 'height=$(tput lines); start={2}; context=$((height / 2)); bat --color=always --paging=never --highlight-line {2} --line-range $((start > context ? start - context : 1)):$((start + context)) {1}')

  # Extracting the file name from the selected line
  local file=$(echo "$file_and_location" | awk -F: '{print $1}')

  if [[ ! -z "$file" ]]; then
    open "$file"
  fi
}

function gc() {
  git commit -v -a -m "$*"
}

function gd() {
  git difftool $1 -t Kaleidoscope -y
}

function gbt() {
  git checkout -b $1 --track origin/$1
}

git-add-origin() {
  local remote_name="${1:-origin}"
  local repo_name=$(gh repo view --json name --jq '.name')
  git remote add "$remote_name" "https://github.com/iloveitaly/$repo_name.git"
}

function myprs() {
  local id=$(set -e; gh pr list -L100 --author $(git config github.user) $@ | fzf | cut -f1)

  [ -n "$id" ] && gh pr view "$id" --web && echo "$id"
}

# TODO should probably remove
# https://blog.takanabe.tokyo/en/2020/04/remove-squash-merged-local-git-branches/
function git-clean-squash-and-merge() (
  set -euo pipefail

  # xargs to trim whitespace https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)
  echo "Using $master_branch as master"

  git checkout -q $master_branch
  git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do
    local ancestor=$(git merge-base $master_branch $branch)

    if [[ $(git cherry main $(git commit-tree $(git rev-parse $branch'^{tree}') -p $ancestor -m _)) == "-"* ]]; then
      git branch -D $branch
    fi
  done
)

# make a gif out of the last recorded video
function makegif() {
  # make sure to include trailing slash
  # TODO we should be able to determine the default SS directly automatically
  screenshot_dir=~/Desktop/

  latest_movie=$screenshot_dir`/bin/ls -tp "$screenshot_dir" | grep '.*\.mov' | head -n 1`
  gif_destination=`echo "$latest_movie" | sed 's/.mov/.gif/'`

  # `brew install ffmpeg gifsicle`
  ffmpeg -i "$latest_movie" -r 10 -f gif - | gifsicle > "$gif_destination"

  echo $gif_destination
  open -a "Google Chrome" "$gif_destination"
}

function httpless {
  http --pretty=all --print=hb "$@" | less -R
}

# Explore a JSON file using Node.
#
# Usage:
#
#     nq <node expression> <file>
#     nq <file>
#
# Examples:
#
#     # Evaluate a JavaScript expression with `$` substituted for the parsed
#     # `data.json`
#     nq '$.filter(d => !!d).map(d => d.length)' data.json
#
#     # Launch an interactive node REPL with the `$` variable assigned to the
#     # parsed `data.json`
#     nq 'data.json'
#
nq() {
  if [ $# -gt 1 ]; then
    node -e "const $ = JSON.parse(require('fs').readFileSync('$2')); console.log($1)"
  else
    node -i -e "const $ = JSON.parse(require('fs').readFileSync('$1'))"
  fi
}

# ripgrep "only": only display the matching text in the first capture group
# this is helpful for selecting and transforming
rgo() {
  params=()

  # check if the user is passing in `-r`, if not, then default to a basic option
  if ((${@[(I)*-r*]} == 0)); then
    params+=("-r \$1")
  fi

  rg $@ $params --no-filename --no-column --no-line-number --color never --only-matching
}

decryptpdf() {
  echo "Enter password followed by <enter> followed by <ctrl-D>"
  qpdf --decrypt --password-file=- --replace-input "${1}"
}

# https://superuser.com/questions/55040/save-a-single-web-page-with-background-images-with-wget/136335#136335
scrape-website() {
  wget -E -H -k -K -p -e robots=off $@
}

###########################
# File opening functions
###########################

# open "yank.tmux:56:109:" at the right line in your terminal
open_in_nano() {
  # Read the input string into variables, splitting by ':'
  IFS=':' read file line column <<< "$1"
  # Open the file at the specified line. Nano doesn't support specific column.
  nano +$line "$file" < /dev/tty
}

open_in_vscode() {
  # git-fuzzy will pass a string that looks like `M  bin/run.js` or ` M bin/run.js`

  # write a ripgrep command which:
  # * ` M bin/run.js` => `bin/run.js`
  # * `test/scraper.test.js:25:40` => `test/scraper.test.js:25:40`
  # * `test/scraper.test.js` => `test/scraper.test.js`
  # assume each of inputs are passed on a single line and are only passed one at a time

  local file=$(pcregrep -o2 "(^\s?M\s)?(.*)" <<< "$1")

  IFS=':' read file line column <<< "$file"

  # remove multiple slashes that could have been passed from `file:///` references
  file=$(echo "$file" | sed 's|^/{2,}|/|')

  code --goto "$file:$line:$column"
}

open_in_cat() {
  IFS=':' read file line column <<< "$1"
  bat $file --highlight-line "$line"
}

source ~/.node-functions