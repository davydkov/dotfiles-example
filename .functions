function touchp() {
  mkdir -p $(dirname $1) && touch "$1"
}

# All the dig info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# git functions
# most pulled from https://github.com/ignu/dotfiles

function gc() {
  git commit -v -a -m "$*"
}

function gd() {
  git difftool $1 -t Kaleidoscope -y
}

# this caused strange terminal input glitches when written as an alias
function gcb() {
  git checkout $(git branch --sort=-committerdate --format="%(refname:short)" | fzf)
}

function gbt() {
  git checkout -b $1 --track origin/$1
}

# https://blog.takanabe.tokyo/en/2020/04/remove-squash-merged-local-git-branches/
function git-clean-squash-and-merge() (
  set -euo pipefail

  # xargs to trim whitespace https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
  local master_branch=$(git branch -l master main | sed 's/^* //' | xargs)
  echo "Using $master_branch as master"

  git checkout -q $master_branch
  git for-each-ref refs/heads/ "--format=%(refname:short)" | while read branch; do
    local ancestor=$(git merge-base $master_branch $branch)

    if [[ $(git cherry main $(git commit-tree $(git rev-parse $branch'^{tree}') -p $ancestor -m _)) == "-"* ]]; then
      git branch -D $branch
    fi
  done
)

# make a gif out of the last recorded video
function makegif() {
  # make sure to include trailing slash
  # TODO we should be able to determine the default SS directly automatically
  screenshot_dir=~/Desktop/

  latest_movie=$screenshot_dir`/bin/ls -tp "$screenshot_dir" | grep '.*\.mov' | head -n 1`
  gif_destination=`echo "$latest_movie" | sed 's/.mov/.gif/'`

  # `brew install ffmpeg gifsicle`
  ffmpeg -i "$latest_movie" -r 10 -f gif - | gifsicle > "$gif_destination"

  echo $gif_destination
  open -a "Google Chrome" "$gif_destination"
}

function httpless {
  http --pretty=all --print=hb "$@" | less -R
}

# Explore a JSON file using Node.
#
# Usage:
#
#     nq <node expression> <file>
#     nq <file>
#
# Examples:
#
#     # Evaluate a JavaScript expression with `$` substituted for the parsed
#     # `data.json`
#     nq '$.filter(d => !!d).map(d => d.length)' data.json
#
#     # Launch an interactive node REPL with the `$` variable assigned to the
#     # parsed `data.json`
#     nq 'data.json'
#
nq() {
  if [ $# -gt 1 ]; then
    node -e "const $ = JSON.parse(require('fs').readFileSync('$2')); console.log($1)"
  else
    node -i -e "const $ = JSON.parse(require('fs').readFileSync('$1'))"
  fi
}

# ripgrep "only": only display the matching text in the first capture group
# this is helpful for selecting and transforming
rgo() {
  params=()

  # check if the user is passing in `-r`, if not, then default to a basic option
  if ((${@[(I)*-r*]} == 0)); then
    params+=("-r \$1")
  fi

  rg $@ $params --no-filename --no-column --no-line-number --color never --only-matching
}